{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview These pages contain documentation about common used technology and concepts in Software Development.","title":"Home"},{"location":"#overview","text":"These pages contain documentation about common used technology and concepts in Software Development.","title":"Overview"},{"location":"concepts/","text":"SOLID Single Responsibility Principle Elke klasse of module heeft de verantwoordelijkheid over \u00e9\u00e9n functionaliteit. (Kan doorgetrokken worden tot methodes). Open/Closed \u201cSoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\u201d. Je moet een klasse of module kunnen uitbreiden (open) zonder ze aan te passen (closed). Een klasse moet verschillende scenario\u2019s aankunnen die nog niet nader gedefinieerd zijn, zonder ze hiervoor aan te passen. Bvb: klasse rechthoek met lengte en breedte, en een klasse voor het berekenen van een totale oppervlakte van een verzameling van rechthoeken. Public class Rectangle { public double Width {get; set;} public double Height {get; set;} } Public class AreaCalculator { public double Area(Rectangle[] shapes) { double area = 0; foreach(var shape in shapes) { area += shape.Width*shape.Height; } return area; } } Bovenstaande klasse kan niet uitgebreid worden naar andere objecten, beter is dus de oppervlakte op object niveau, zodat de areacalculator kan uitgebreid worden naar andere objecten zoals cirkels, zonder deze te moeten aanpassen: public double Area(Shape[] shapes) { double area = 0; foreach (var shape in shapes) { area += shape.Area(); } return area; } Liskov Substitution Elke afgeleide klasse moet gesubstitueerd kunnen worden voor zijn base/parent. Wanneer een klasse dus in plaats van zijn parent gebruikt wordt, moet alle functionaliteit op dezelfde manier blijven werken. A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The \"is a\" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn't make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one. Interface Segregation Elke implementatie van een interface of supertype moet gebruik kunnen maken van alle methodes die overge\u00ebrfd of ge\u00efmplementeerd worden. Er zou nooit een nutteloze methode mogen ge\u00ebrfd of ge\u00efmplementeerd worden. Het opsplitsen van interfaces en klassen indien nodig. Hangt sterk samen met Single Responsibility Principle Verschil tussen Single Responsibility Principle en Interface Segregation is vanwaar je het bekijkt. Zelfde principe vanuit twee verschillende oogpunten: SRP tells us that you should only have a single responsibility in a module. ISP tells us that you should not be forced to be confronted with more than you actually need. If you want to use a print() method from interface I, you shouldn't have to instantiate a SwimmingPoolor a DriveThru class for that. More concretely, and going straight to the point, they are different views on the same idea -- SRP is more focused on the designer-side point-of-view, while ISP is more focused on the client-side point-of-view. So you're basically right. The ISP was first used and formulated by Robert C. Martin while consulting for Xerox. Xerox had created a new printer system that could perform a variety of tasks such as stapling and faxing. The software for this system was created from the ground up. As the software grew, making modifications became more and more difficult so that even the smallest change would take a redeployment cycle of an hour, which made development nearly impossible. The design problem was that a single Job class was used by almost all of the tasks. Whenever a print job or a stapling job needed to be performed, a call was made to the Job class. This resulted in a 'fat' class with multitudes of methods specific to a variety of different clients. Because of this design, a staple job would know about all the methods of the print job, even though there was no use for them. The solution suggested by Martin utilized what is today called the Interface Segregation Principle. Applied to the Xerox software, an interface layer between the Job class and its clients was added using the Dependency Inversion Principle. Instead of having one large Job class, a Staple Job interface or a Print Job interface was created that would be used by the Staple or Print classes, respectively, calling methods of the Job class. Therefore, one interface was created for each job type, which was all implemented by the Job class. Dependency Inversion High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. Zorgt voor Decoupling - Loose coupling In volgend voorbeeld is de hogere level klasse Notification afhankelijk van een lager level klasse Email. Bij nieuwe objecten moet de code gewijzigd worden. public class Email { public void SendEmail() { // code } } public class Notification { private Email _email; public Notification() { _email = new Email(); } public void PromotionalNotification() { _email.SendEmail(); } } We lossen deze afhankelijkheid op door een abstractie te maken tussen de twee klassen. Nu is notificatie enkel afhankelijk van een abstracte messageservice, waardoor nieuwe implementaties eenvoudig toegevoegd kunnen worden. public interface IMessageService { void SendMessage(); } public class Email : IMessageService { public void SendMessage() { // code } } public class Notification { private IMessageService _iMessageService; public Notification() { _iMessageService = new Email(); } public void PromotionalNotification() { _iMessageService.SendMessage(); } } We moeten enkel nog via Dependency Injection de afhankelijkheid weghalen door het object via de constructor te injecteren zoals hieronder. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } } Dependency Inversion vs Dependency Injection Als we in onderstaand voorbeeld geen Interface injecteren via Dependency Injection, maar een concrete implementatie via een object, dan doen we aan Dependency Injection maar niet aan Dependency Inversion: de klasse geeft de controle van het instanti\u00ebren af, maar is afhankelijk van een concrete implementatie ipv een abstractie waardoor de klassen nog steeds niet loosely coupled zijn. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } } .NET .NET Framework The .NET Framework consists of the common language runtime (CLR) and the .NET Framework class library . De CLR (de runtime) is een virtuele machine en manages code at execution time: Geheugenbeheer Threadbeheer Exception handling Garbage collection Security Ontwikkelaars die CLR gebruiken schrijven hun code in een zogenaamd hogere programmeertaal zoals C#, Scala of VB.NET. Tijdens het compileren zorgt een .NET-compiler ervoor dat de broncode wordt omgezet naar MSIL, welke tijdens het uitvoeren door de just in time compiler van de CLR wordt gecompileerd naar code die uitgevoerd kan worden op het systeem waar de CLR op dat moment op draait. Dit zorgt ervoor dat applicaties niet hardware afhankelijk zijn, en dus op elk willekeurig systeem kunnen worden uitgevoerd, zolang er een CLR voor is. Door dit proces zijn applicaties wel (iets) trager, omdat ze tijdens het uitvoeren gecompileerd worden.","title":"Theory"},{"location":"concepts/#solid","text":"","title":"SOLID"},{"location":"concepts/#single-responsibility-principle","text":"Elke klasse of module heeft de verantwoordelijkheid over \u00e9\u00e9n functionaliteit. (Kan doorgetrokken worden tot methodes).","title":"Single Responsibility Principle"},{"location":"concepts/#openclosed","text":"\u201cSoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\u201d. Je moet een klasse of module kunnen uitbreiden (open) zonder ze aan te passen (closed). Een klasse moet verschillende scenario\u2019s aankunnen die nog niet nader gedefinieerd zijn, zonder ze hiervoor aan te passen. Bvb: klasse rechthoek met lengte en breedte, en een klasse voor het berekenen van een totale oppervlakte van een verzameling van rechthoeken. Public class Rectangle { public double Width {get; set;} public double Height {get; set;} } Public class AreaCalculator { public double Area(Rectangle[] shapes) { double area = 0; foreach(var shape in shapes) { area += shape.Width*shape.Height; } return area; } } Bovenstaande klasse kan niet uitgebreid worden naar andere objecten, beter is dus de oppervlakte op object niveau, zodat de areacalculator kan uitgebreid worden naar andere objecten zoals cirkels, zonder deze te moeten aanpassen: public double Area(Shape[] shapes) { double area = 0; foreach (var shape in shapes) { area += shape.Area(); } return area; }","title":"Open/Closed"},{"location":"concepts/#liskov-substitution","text":"Elke afgeleide klasse moet gesubstitueerd kunnen worden voor zijn base/parent. Wanneer een klasse dus in plaats van zijn parent gebruikt wordt, moet alle functionaliteit op dezelfde manier blijven werken. A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The \"is a\" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn't make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one.","title":"Liskov Substitution"},{"location":"concepts/#interface-segregation","text":"Elke implementatie van een interface of supertype moet gebruik kunnen maken van alle methodes die overge\u00ebrfd of ge\u00efmplementeerd worden. Er zou nooit een nutteloze methode mogen ge\u00ebrfd of ge\u00efmplementeerd worden. Het opsplitsen van interfaces en klassen indien nodig. Hangt sterk samen met Single Responsibility Principle Verschil tussen Single Responsibility Principle en Interface Segregation is vanwaar je het bekijkt. Zelfde principe vanuit twee verschillende oogpunten: SRP tells us that you should only have a single responsibility in a module. ISP tells us that you should not be forced to be confronted with more than you actually need. If you want to use a print() method from interface I, you shouldn't have to instantiate a SwimmingPoolor a DriveThru class for that. More concretely, and going straight to the point, they are different views on the same idea -- SRP is more focused on the designer-side point-of-view, while ISP is more focused on the client-side point-of-view. So you're basically right. The ISP was first used and formulated by Robert C. Martin while consulting for Xerox. Xerox had created a new printer system that could perform a variety of tasks such as stapling and faxing. The software for this system was created from the ground up. As the software grew, making modifications became more and more difficult so that even the smallest change would take a redeployment cycle of an hour, which made development nearly impossible. The design problem was that a single Job class was used by almost all of the tasks. Whenever a print job or a stapling job needed to be performed, a call was made to the Job class. This resulted in a 'fat' class with multitudes of methods specific to a variety of different clients. Because of this design, a staple job would know about all the methods of the print job, even though there was no use for them. The solution suggested by Martin utilized what is today called the Interface Segregation Principle. Applied to the Xerox software, an interface layer between the Job class and its clients was added using the Dependency Inversion Principle. Instead of having one large Job class, a Staple Job interface or a Print Job interface was created that would be used by the Staple or Print classes, respectively, calling methods of the Job class. Therefore, one interface was created for each job type, which was all implemented by the Job class.","title":"Interface Segregation"},{"location":"concepts/#dependency-inversion","text":"High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. Zorgt voor Decoupling - Loose coupling In volgend voorbeeld is de hogere level klasse Notification afhankelijk van een lager level klasse Email. Bij nieuwe objecten moet de code gewijzigd worden. public class Email { public void SendEmail() { // code } } public class Notification { private Email _email; public Notification() { _email = new Email(); } public void PromotionalNotification() { _email.SendEmail(); } } We lossen deze afhankelijkheid op door een abstractie te maken tussen de twee klassen. Nu is notificatie enkel afhankelijk van een abstracte messageservice, waardoor nieuwe implementaties eenvoudig toegevoegd kunnen worden. public interface IMessageService { void SendMessage(); } public class Email : IMessageService { public void SendMessage() { // code } } public class Notification { private IMessageService _iMessageService; public Notification() { _iMessageService = new Email(); } public void PromotionalNotification() { _iMessageService.SendMessage(); } } We moeten enkel nog via Dependency Injection de afhankelijkheid weghalen door het object via de constructor te injecteren zoals hieronder. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } }","title":"Dependency Inversion"},{"location":"concepts/#dependency-inversion-vs-dependency-injection","text":"Als we in onderstaand voorbeeld geen Interface injecteren via Dependency Injection, maar een concrete implementatie via een object, dan doen we aan Dependency Injection maar niet aan Dependency Inversion: de klasse geeft de controle van het instanti\u00ebren af, maar is afhankelijk van een concrete implementatie ipv een abstractie waardoor de klassen nog steeds niet loosely coupled zijn. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } }","title":"Dependency Inversion vs Dependency Injection"},{"location":"concepts/#net","text":"","title":".NET"},{"location":"concepts/#net-framework","text":"The .NET Framework consists of the common language runtime (CLR) and the .NET Framework class library . De CLR (de runtime) is een virtuele machine en manages code at execution time: Geheugenbeheer Threadbeheer Exception handling Garbage collection Security Ontwikkelaars die CLR gebruiken schrijven hun code in een zogenaamd hogere programmeertaal zoals C#, Scala of VB.NET. Tijdens het compileren zorgt een .NET-compiler ervoor dat de broncode wordt omgezet naar MSIL, welke tijdens het uitvoeren door de just in time compiler van de CLR wordt gecompileerd naar code die uitgevoerd kan worden op het systeem waar de CLR op dat moment op draait. Dit zorgt ervoor dat applicaties niet hardware afhankelijk zijn, en dus op elk willekeurig systeem kunnen worden uitgevoerd, zolang er een CLR voor is. Door dit proces zijn applicaties wel (iets) trager, omdat ze tijdens het uitvoeren gecompileerd worden.","title":".NET Framework"},{"location":"git/","text":"GIT Overview Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. Example: stage, commit and push changes to remote repository called origin. git add * git commit -m bugfix git fetch origin git pull origin git push origin --all Example: push exisiting project to new remote repository (without readme) Step 1: Create local repository and commit changes git init git add . git commit -m Initial commit Step 2: add remote and push changes to remote git remote add origin remote_origin_url git remote -v (verifies then new remote URL) git push origin master Initialize git init --- create new local repository git clone --- create copy of an existing repository, automatically creates a remote connection called origin Saving changes The commands: git add , git status , and git commit are all used in combination to save a snapshot of a Git project's current state. git add --- stages changes git status --- checks which files are staged git reset --- undo a git add git commit --- commits the staged changes to the local repository Stashing changes Stashing takes your uncommitted changes (both staged and unstaged) , saves them away for later use, and then reverts them from your working copy. git stash --- temporarily shelves changes git stash pop --- reaplly stashed changes to local working copy Git stash does not stash untracked files (new files). To stash new files you can add -u (--include-untracked) git stash -u --- stashes changes with untracked files Syncing with remote repository Configuring remote A remote repository can be reached through a URL and credentials. Git remote allows you to creates an alias for easy use of the URL of the remote repository. git remote --- get current remote configurations git remote -v --- same as the above but includes the URL of each remote git remote add name url --- adds a new remote git remote rm name --- remove remote Pushing git push remote branch Merge vs Rebase Both try to achieve the same result, but rebase rewrites the history by 'rebasing' one branch on top of the other, creating a lineair history. This prevents cluttering with merge commits, but can create confusing situations by creating a different history with other team members. Link to explanation","title":"GIT"},{"location":"git/#git","text":"","title":"GIT"},{"location":"git/#overview","text":"Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. Example: stage, commit and push changes to remote repository called origin. git add * git commit -m bugfix git fetch origin git pull origin git push origin --all Example: push exisiting project to new remote repository (without readme) Step 1: Create local repository and commit changes git init git add . git commit -m Initial commit Step 2: add remote and push changes to remote git remote add origin remote_origin_url git remote -v (verifies then new remote URL) git push origin master","title":"Overview"},{"location":"git/#initialize","text":"git init --- create new local repository git clone --- create copy of an existing repository, automatically creates a remote connection called origin","title":"Initialize"},{"location":"git/#saving-changes","text":"The commands: git add , git status , and git commit are all used in combination to save a snapshot of a Git project's current state. git add --- stages changes git status --- checks which files are staged git reset --- undo a git add git commit --- commits the staged changes to the local repository","title":"Saving changes"},{"location":"git/#stashing-changes","text":"Stashing takes your uncommitted changes (both staged and unstaged) , saves them away for later use, and then reverts them from your working copy. git stash --- temporarily shelves changes git stash pop --- reaplly stashed changes to local working copy Git stash does not stash untracked files (new files). To stash new files you can add -u (--include-untracked) git stash -u --- stashes changes with untracked files","title":"Stashing changes"},{"location":"git/#syncing-with-remote-repository","text":"","title":"Syncing with remote repository"},{"location":"git/#configuring-remote","text":"A remote repository can be reached through a URL and credentials. Git remote allows you to creates an alias for easy use of the URL of the remote repository. git remote --- get current remote configurations git remote -v --- same as the above but includes the URL of each remote git remote add name url --- adds a new remote git remote rm name --- remove remote","title":"Configuring remote"},{"location":"git/#pushing","text":"git push remote branch","title":"Pushing"},{"location":"git/#merge-vs-rebase","text":"Both try to achieve the same result, but rebase rewrites the history by 'rebasing' one branch on top of the other, creating a lineair history. This prevents cluttering with merge commits, but can create confusing situations by creating a different history with other team members. Link to explanation","title":"Merge vs Rebase"},{"location":"mkdocs/","text":"MkDocs Generates static sites based on markdown files. https://www.mkdocs.org mkdocs serve - Start the live-reloading docs server. Launch in directory of .yml file. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploys the pages to Github Project Pages Markdown sheat-sheet: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#lines Live Page","title":"MkDocs"},{"location":"mkdocs/#mkdocs","text":"Generates static sites based on markdown files. https://www.mkdocs.org mkdocs serve - Start the live-reloading docs server. Launch in directory of .yml file. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploys the pages to Github Project Pages Markdown sheat-sheet: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#lines Live Page","title":"MkDocs"},{"location":"netwerkbeheer/","text":"Netwerkbeheer DHCP Client DHCP Server DHCP opties: Ip adres Subnetmask gateway dns dns suffix Switch toevoegen ip adres geven: netwerk config - dhcp DNS surf naar www.google.com - zoekt ip adres Twee lokale opzoekingen, daarna neemt uw dns server het over. (lokaal is dat dns server van bv. telenet) check etc/hosts daarna dns cache daarna vraagt hij aan dns server in domein client - DNS server (hik.be) \u2192 internet root server root server verwijst u naar .com dns server \u2192 google.com dns server \u2192 drive.google.com dns server Active Directory Kan niet zonder DNS! Voor AD moest je op elke PC een gebruiker aanmaken om te kunnen authenticeren. Authenticatie gaat via Kerberos op de Domain Controller (waar AD staat). Kerberos stuurt tickets voor toegang - zie youtube video. Kleine bedrijven: kan via Azure AD, voor grote bedrijven niet voldoende (geen LDAP ondersteuning bvb.). Kan onder meerdere domeinen (subdomeinen dan eigenlijk). Maar geeft problemen voor authenticatie in cloud, dus meer en meer \u00e9\u00e9n groot domein. Functie Domein Controller(s): Host databank van AD Repliceren elkaar (niet zoals bij DNS waarbij \u00e9\u00e9n hoofd DNS (primary zone) en een backup DNS (secondary zone) Domain Controller: geef ip adres: 10.10 installeer rollen maak domeincontroller: cursusdom.be 5 rollen: (FSMO) (kunnen bij \u00e9\u00e9n domeincontroller) RID Master: verdeeld groepen van security identifiers aan de andere domein controllers: zijn deze op moet je opnieuw bij de RID master nieuwe keys ophalen. PDC emulator: distributie van verandering naar andere domein controllers Schema Master: houdt bij hoe u database er uit ziet. Domein Naming Master: Infrastructure Master: Core Veel instellingen kunnen ook via sconfig naam wijzigen get current computername: hostname wmic computersystem where caption='xp-pc' rename windows7-pc ip aanpassen get name of interface: netsh interface show interface change ip adress: netsh interface ip set address \"Ethernet\" static 10.0.0.100 255.255.0.0 10.0.0.1 1 show change: netsh interface show interface windows update uitzetten BETER via powershell: stop-service wuauserv set-service wuauserv -StartupType Disabled firewall uitzetten netsh advfirewall set allprofiles state off Toevoegen aan domain (cursusdom.be) 1. Eerst moet je DNS Server configureren, anders geraak je niet aan het domein * netsh interface ipv4 add dnsserver \"Ethernet\" address=192.168.x.x index=1 2. Met volgende command kan je de lokale pc toevoegen aan het domein. Hierbij moet je je authenticeren met een account van het domein. * netdom join %THE_COMPUTER_NAME% /domain:OPSCODEDEMO.COM /userd:Administrator /passwordd:xxx Kan rechtstreeks (via GUI) via system - Fileserver van maken Kan eenvoudiger via de Domein Controller - Server Manager - All Servers - Server toevoegen via zoekfunctie - Functies en rollen installeren. start powershell Install-WindowsFeature \u2013Name FS-Resource-Manager Folder C:DATA sharen Beter via Server manager: fileserver - shares - tasks - new New-SMBShare \u2013Name \"Shared\" \u2013Path \"C:\\Shared\" \u2013ContinuouslyAvailable \u2013FullAccess domain\\admingroup ` Test via nieuwe netwerklocatie aan te maken: \\ServerCore\\Data Kan ook gewoon via \\ServerCore - laat alle shared mappen zien Mogelijke problemen: IP instellingen: fixed IP DNS Server Gateway instellingen Gekoppeld aan virtuele switch? Firewall? Pingen indien geen reply en bovenstaande is ok - Firewall staat op Check of DNS werkt. (ping domein ipv ip-adres of NSLookup) AGDLP Account Global Group Domain Local Group Permission Account Global Group Domain Local Group Permission (use NTFS) Jos.Smet GG_HR DL_HR_R(read) centered DL_HR_W(write) HR (share map) are neat DL_HR_FC(fullctr) Bij folder sharen: Share altijd everyone full control en dan per gebruiker/group met NTFS Inheritance altijd uit Op examen niet rechtstreeks, maar altijd met groep structuur werken: OU: cursusdom OU: groepen/users/computers/servers groepen: Global Groups GG_HR, etc. Voordeel van computer toe te voegen op domein: iedere gebruiker binnen domein kan aanmelden via die pc pc kan beheerd worden vanaf netwerk Powershell Syntax $PSItem or $_ Gets the item in a foreach or after the pipeline. $ (dollar underscore) 'THIS' token. Typically refers to the item inside a foreach loop. Task: Print all items in a collection. Solution. ... | foreach { Write-Host $ } get-process | where-object {$_.cpu -gt 1 -and $_.company -ne 'Microsoft Corporation'} | ft name, cpu, company Comparators -eq Equal -ne Not equal -ge Greater than or equal -gt Greater than -lt Less than -le Less than or equal -like Wildcard comparison -notlike Wildcard comparison -match Regular expression comparison -notmatch Regular expression comparison -replace Replace operator -contains Containment operator -notcontains Containment operator -in Like \u2013contains, but with the operands reversed.(PowerShell 3.0) -notin Like \u2013notcontains, but with the operands reversed.(PowerShell 3.0) get-childitem | c:\\windows | where-object LastAccessTime -gt (Get-Date).AddMonths(-1) Useful commands Get-process get-process --- toont alle processen get-process -name notepad --- toont running notepad processen get-process -name n* --- toont alle processen starting with N Stop-process stop-process -name notepad --- stop all notepad processen stop-process -name notepad -whatif --- check which processes would have been stopped Get-Date Shows current date. (Get-Date).DayOfWeek --- dag van de week (Get-Date).AddYears/AddDays/ --- add amount of time to dat Get-Date -Day 1 -Month 7 -Year (Get-Date).Year --- toont op welke dag 1 juli van het huidig jaar valt","title":"Netwerkbeheer"},{"location":"netwerkbeheer/#netwerkbeheer","text":"","title":"Netwerkbeheer"},{"location":"netwerkbeheer/#dhcp","text":"Client DHCP Server DHCP opties: Ip adres Subnetmask gateway dns dns suffix Switch toevoegen ip adres geven: netwerk config - dhcp","title":"DHCP"},{"location":"netwerkbeheer/#dns","text":"surf naar www.google.com - zoekt ip adres Twee lokale opzoekingen, daarna neemt uw dns server het over. (lokaal is dat dns server van bv. telenet) check etc/hosts daarna dns cache daarna vraagt hij aan dns server in domein client - DNS server (hik.be) \u2192 internet root server root server verwijst u naar .com dns server \u2192 google.com dns server \u2192 drive.google.com dns server","title":"DNS"},{"location":"netwerkbeheer/#active-directory","text":"Kan niet zonder DNS! Voor AD moest je op elke PC een gebruiker aanmaken om te kunnen authenticeren. Authenticatie gaat via Kerberos op de Domain Controller (waar AD staat). Kerberos stuurt tickets voor toegang - zie youtube video. Kleine bedrijven: kan via Azure AD, voor grote bedrijven niet voldoende (geen LDAP ondersteuning bvb.). Kan onder meerdere domeinen (subdomeinen dan eigenlijk). Maar geeft problemen voor authenticatie in cloud, dus meer en meer \u00e9\u00e9n groot domein. Functie Domein Controller(s): Host databank van AD Repliceren elkaar (niet zoals bij DNS waarbij \u00e9\u00e9n hoofd DNS (primary zone) en een backup DNS (secondary zone)","title":"Active Directory"},{"location":"netwerkbeheer/#domain-controller","text":"geef ip adres: 10.10 installeer rollen maak domeincontroller: cursusdom.be 5 rollen: (FSMO) (kunnen bij \u00e9\u00e9n domeincontroller) RID Master: verdeeld groepen van security identifiers aan de andere domein controllers: zijn deze op moet je opnieuw bij de RID master nieuwe keys ophalen. PDC emulator: distributie van verandering naar andere domein controllers Schema Master: houdt bij hoe u database er uit ziet. Domein Naming Master: Infrastructure Master: Core Veel instellingen kunnen ook via sconfig naam wijzigen get current computername: hostname wmic computersystem where caption='xp-pc' rename windows7-pc ip aanpassen get name of interface: netsh interface show interface change ip adress: netsh interface ip set address \"Ethernet\" static 10.0.0.100 255.255.0.0 10.0.0.1 1 show change: netsh interface show interface windows update uitzetten BETER via powershell: stop-service wuauserv set-service wuauserv -StartupType Disabled firewall uitzetten netsh advfirewall set allprofiles state off Toevoegen aan domain (cursusdom.be) 1. Eerst moet je DNS Server configureren, anders geraak je niet aan het domein * netsh interface ipv4 add dnsserver \"Ethernet\" address=192.168.x.x index=1 2. Met volgende command kan je de lokale pc toevoegen aan het domein. Hierbij moet je je authenticeren met een account van het domein. * netdom join %THE_COMPUTER_NAME% /domain:OPSCODEDEMO.COM /userd:Administrator /passwordd:xxx Kan rechtstreeks (via GUI) via system - Fileserver van maken Kan eenvoudiger via de Domein Controller - Server Manager - All Servers - Server toevoegen via zoekfunctie - Functies en rollen installeren. start powershell Install-WindowsFeature \u2013Name FS-Resource-Manager Folder C:DATA sharen Beter via Server manager: fileserver - shares - tasks - new New-SMBShare \u2013Name \"Shared\" \u2013Path \"C:\\Shared\" \u2013ContinuouslyAvailable \u2013FullAccess domain\\admingroup ` Test via nieuwe netwerklocatie aan te maken: \\ServerCore\\Data Kan ook gewoon via \\ServerCore - laat alle shared mappen zien Mogelijke problemen: IP instellingen: fixed IP DNS Server Gateway instellingen Gekoppeld aan virtuele switch? Firewall? Pingen indien geen reply en bovenstaande is ok - Firewall staat op Check of DNS werkt. (ping domein ipv ip-adres of NSLookup)","title":"Domain Controller:"},{"location":"netwerkbeheer/#agdlp","text":"Account Global Group Domain Local Group Permission Account Global Group Domain Local Group Permission (use NTFS) Jos.Smet GG_HR DL_HR_R(read) centered DL_HR_W(write) HR (share map) are neat DL_HR_FC(fullctr) Bij folder sharen: Share altijd everyone full control en dan per gebruiker/group met NTFS Inheritance altijd uit Op examen niet rechtstreeks, maar altijd met groep structuur werken: OU: cursusdom OU: groepen/users/computers/servers groepen: Global Groups GG_HR, etc. Voordeel van computer toe te voegen op domein: iedere gebruiker binnen domein kan aanmelden via die pc pc kan beheerd worden vanaf netwerk","title":"AGDLP"},{"location":"netwerkbeheer/#powershell","text":"","title":"Powershell"},{"location":"netwerkbeheer/#syntax","text":"","title":"Syntax"},{"location":"netwerkbeheer/#psitem-or-_","text":"Gets the item in a foreach or after the pipeline. $ (dollar underscore) 'THIS' token. Typically refers to the item inside a foreach loop. Task: Print all items in a collection. Solution. ... | foreach { Write-Host $ } get-process | where-object {$_.cpu -gt 1 -and $_.company -ne 'Microsoft Corporation'} | ft name, cpu, company","title":"$PSItem or $_"},{"location":"netwerkbeheer/#comparators","text":"-eq Equal -ne Not equal -ge Greater than or equal -gt Greater than -lt Less than -le Less than or equal -like Wildcard comparison -notlike Wildcard comparison -match Regular expression comparison -notmatch Regular expression comparison -replace Replace operator -contains Containment operator -notcontains Containment operator -in Like \u2013contains, but with the operands reversed.(PowerShell 3.0) -notin Like \u2013notcontains, but with the operands reversed.(PowerShell 3.0) get-childitem | c:\\windows | where-object LastAccessTime -gt (Get-Date).AddMonths(-1)","title":"Comparators"},{"location":"netwerkbeheer/#useful-commands","text":"","title":"Useful commands"},{"location":"netwerkbeheer/#get-process","text":"get-process --- toont alle processen get-process -name notepad --- toont running notepad processen get-process -name n* --- toont alle processen starting with N","title":"Get-process"},{"location":"netwerkbeheer/#stop-process","text":"stop-process -name notepad --- stop all notepad processen stop-process -name notepad -whatif --- check which processes would have been stopped","title":"Stop-process"},{"location":"netwerkbeheer/#get-date","text":"Shows current date. (Get-Date).DayOfWeek --- dag van de week (Get-Date).AddYears/AddDays/ --- add amount of time to dat Get-Date -Day 1 -Month 7 -Year (Get-Date).Year --- toont op welke dag 1 juli van het huidig jaar valt","title":"Get-Date"}]}