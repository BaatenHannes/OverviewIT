{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SOLID Single Responsibility Principle Elke klasse of module heeft de verantwoordelijkheid over \u00e9\u00e9n functionaliteit. (Kan doorgetrokken worden tot methodes). Open/Closed \u201cSoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\u201d. Je moet een klasse of module kunnen uitbreiden (open) zonder ze aan te passen (closed). Een klasse moet verschillende scenario\u2019s aankunnen die nog niet nader gedefinieerd zijn, zonder ze hiervoor aan te passen. Bvb: klasse rechthoek met lengte en breedte, en een klasse voor het berekenen van een totale oppervlakte van een verzameling van rechthoeken. Public class Rectangle { public double Width {get; set;} public double Height {get; set;} } Public class AreaCalculator { public double Area(Rectangle[] shapes) { double area = 0; foreach(var shape in shapes) { area += shape.Width*shape.Height; } return area; } } Bovenstaande klasse kan niet uitgebreid worden naar andere objecten, beter is dus de oppervlakte op object niveau, zodat de areacalculator kan uitgebreid worden naar andere objecten zoals cirkels, zonder deze te moeten aanpassen: public double Area(Shape[] shapes) { double area = 0; foreach (var shape in shapes) { area += shape.Area(); } return area; } Liskov Substitution Elke afgeleide klasse moet gesubstitueerd kunnen worden voor zijn base/parent. Wanneer een klasse dus in plaats van zijn parent gebruikt wordt, moet alle functionaliteit op dezelfde manier blijven werken. A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The \"is a\" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn't make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one. Interface Segregation Elke implementatie van een interface of supertype moet gebruik kunnen maken van alle methodes die overge\u00ebrfd of ge\u00efmplementeerd worden. Er zou nooit een nutteloze methode mogen ge\u00ebrfd of ge\u00efmplementeerd worden. Het opsplitsen van interfaces en klassen indien nodig. Hangt sterk samen met Single Responsibility Principle Verschil tussen Single Responsibility Principle en Interface Segregation is vanwaar je het bekijkt. Zelfde principe vanuit twee verschillende oogpunten: SRP tells us that you should only have a single responsibility in a module. ISP tells us that you should not be forced to be confronted with more than you actually need. If you want to use a print() method from interface I, you shouldn't have to instantiate a SwimmingPoolor a DriveThru class for that. More concretely, and going straight to the point, they are different views on the same idea -- SRP is more focused on the designer-side point-of-view, while ISP is more focused on the client-side point-of-view. So you're basically right. The ISP was first used and formulated by Robert C. Martin while consulting for Xerox. Xerox had created a new printer system that could perform a variety of tasks such as stapling and faxing. The software for this system was created from the ground up. As the software grew, making modifications became more and more difficult so that even the smallest change would take a redeployment cycle of an hour, which made development nearly impossible. The design problem was that a single Job class was used by almost all of the tasks. Whenever a print job or a stapling job needed to be performed, a call was made to the Job class. This resulted in a 'fat' class with multitudes of methods specific to a variety of different clients. Because of this design, a staple job would know about all the methods of the print job, even though there was no use for them. The solution suggested by Martin utilized what is today called the Interface Segregation Principle. Applied to the Xerox software, an interface layer between the Job class and its clients was added using the Dependency Inversion Principle. Instead of having one large Job class, a Staple Job interface or a Print Job interface was created that would be used by the Staple or Print classes, respectively, calling methods of the Job class. Therefore, one interface was created for each job type, which was all implemented by the Job class. Dependency Inversion High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. Zorgt voor Decoupling - Loose coupling In volgend voorbeeld is de hogere level klasse Notification afhankelijk van een lager level klasse Email. Bij nieuwe objecten moet de code gewijzigd worden. public class Email { public void SendEmail() { // code } } public class Notification { private Email _email; public Notification() { _email = new Email(); } public void PromotionalNotification() { _email.SendEmail(); } } We lossen deze afhankelijkheid op door een abstractie te maken tussen de twee klassen. Nu is notificatie enkel afhankelijk van een abstracte messageservice, waardoor nieuwe implementaties eenvoudig toegevoegd kunnen worden. public interface IMessageService { void SendMessage(); } public class Email : IMessageService { public void SendMessage() { // code } } public class Notification { private IMessageService _iMessageService; public Notification() { _iMessageService = new Email(); } public void PromotionalNotification() { _iMessageService.SendMessage(); } } We moeten enkel nog via Dependency Injection de afhankelijkheid weghalen door het object via de constructor te injecteren zoals hieronder. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } } Dependency Inversion vs Dependency Injection Als we in onderstaand voorbeeld geen Interface injecteren via Dependency Injection, maar een concrete implementatie via een object, dan doen we aan Dependency Injection maar niet aan Dependency Inversion: de klasse geeft de controle van het instanti\u00ebren af, maar is afhankelijk van een concrete implementatie ipv een abstractie waardoor de klassen nog steeds niet loosely coupled zijn. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } } Inversion Of Control 'Omdraaien van de controle'. The division between the 'What' and the 'When' parts of the code. Code that does not know and care when it will run, it only knows what it will do and depend on abstractions. In traditional programming, the flow of the business logic is determined by objects that are statically bound to one another. With inversion of control, the flow depends on the object graph that is built up during program execution. Such a dynamic flow is made possible by object interactions that are defined through abstractions. This run-time binding is achieved by mechanisms such as dependency injection or a service locator. Factory pattern Service locator pattern Dpeendency injection Strategy pattern Patterns Factory method pattern In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created, by calling a factory method rather than by calling a constructor . Puts the pieces together to make a complete object and hides the concrete type from the caller. \"Define an interface for creating an object, but let subclasses decide which class to instantiate. The Factory method lets a class defer instantiation it uses to subclasses.\" (Gang Of Four) Why and when to use: * A class cannot anticipate the type of objects it needs to create beforehand. * A class requires its subclasses to specify the objects it creates. * You want to localize the logic to instantiate a complex object. Abstract factory pattern Variant on the factory method pattern, where instead of creating object in a factory method, you use a factory class to generate objects of a certain type. This is especially usefull when creating complex objects in multiple different classes. They can all share a factory class to generate objects, and if the composition of the object changes, only the factory class needs to be changed. the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation. with the Abstract Factory pattern , a class delegates the responsibility of object instantiation to another object via composition. Factory method Creates object of a subclass of Foo. Which subclass depends on the subclass of A. Inheritence is used to decide the behaviour of f.whatever(). class A { public void doSomething() { Foo f = makeFoo(); f.whatever(); } protected Foo makeFoo() { return new RegularFoo(); } } class B extends A { protected Foo makeFoo() { //subclass is overriding the factory method //to return something different return new SpecialFoo(); } } Abstract Factory Creates objects of a subclass of Foo. Which subclass depends on the specifiek factory that is injected. This way, the behaviour of f.whatever() depends on the type of factory you inject. class A { private IFactory factory; public A(IFactory factory) { this.factory = factory; } public void doSomething() { //The concrete class of \"f\" depends on the concrete class //of the factory passed into the constructor. If you provide a //different factory, you get a different Foo object. Foo f = factory.makeFoo(); f.whatever(); } } interface IFactory { Foo makeFoo(); Bar makeBar(); Aycufcn makeAmbiguousYetCommonlyUsedFakeClassName(); } //need to make concrete factories that implement the \"Factory\" interface here Strategy Pattern The strategy pattern is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use. Strategy can be assigned to an object by composition, rather then inheritance, implementing an IStrategy interface where you call for example Strategy.DoSomething(). The type of IStrategy will decide the behaviour of the method, and the object can be switched at runtime with another strategy object with another implementation. public static void Main(String[] args) { // Prepare strategies IBillingStrategy normalStrategy = new NormalStrategy(); IBillingStrategy happyHourStrategy = new HappyHourStrategy(); Customer firstCustomer = new Customer(normalStrategy); // Normal billing firstCustomer.Add(1.0, 1); // Start Happy Hour firstCustomer.Strategy = happyHourStrategy; firstCustomer.Add(1.0, 2); // New Customer Customer secondCustomer = new Customer(happyHourStrategy); secondCustomer.Add(0.8, 1); // The Customer pays firstCustomer.PrintBill(); // End Happy Hour secondCustomer.Strategy = normalStrategy; secondCustomer.Add(1.3, 2); secondCustomer.Add(2.5, 1); secondCustomer.PrintBill(); } } The entire code of above example can be found here Singleton Pattern A singleton is a class which only allows one instance of itself to be created - and gives simple, easy access to said instance. This is achieved by: making the constructor private to prevent outside instantiation make a static property which contains one instance of itself public class Singleton { private Singleton() { // Prevent outside instantiation } private static readonly Singleton _singleton = new Singleton(); public static Singleton GetSingleton() { return _singleton; } } .NET .NET Framework The .NET Framework consists of the common language runtime (CLR) and the .NET Framework class library . De CLR (de runtime) is een virtuele machine en manages code at execution time: Geheugenbeheer Threadbeheer Exception handling Garbage collection Security Ontwikkelaars die CLR gebruiken schrijven hun code in een zogenaamd hogere programmeertaal zoals C#, Scala of VB.NET. Tijdens het compileren zorgt een .NET-compiler ervoor dat de broncode wordt omgezet naar MSIL, welke tijdens het uitvoeren door de just in time compiler van de CLR wordt gecompileerd naar code die uitgevoerd kan worden op het systeem waar de CLR op dat moment op draait. Dit zorgt ervoor dat applicaties niet hardware afhankelijk zijn, en dus op elk willekeurig systeem kunnen worden uitgevoerd, zolang er een CLR voor is. Door dit proces zijn applicaties wel (iets) trager, omdat ze tijdens het uitvoeren gecompileerd worden. REST Excellent overview here - https://restfulapi.net/statelessness/ Representational State Transfer is a software architecture used to create web services. RESTful web services allow the requesting systems to access and manipulate textual representations of web resources by using a uniform and predefined set of stateless operations. Architectural properties performance in component interactions, which can be the dominant factor in user-perceived performance and network efficiency;[9] scalability allowing the support of large numbers of components and interactions among components. simplicity of a uniform interface; modifiability of components to meet changing needs (even while the application is running); visibility of communication between components by service agents; portability - usability of the same software in different environments reliability in the resistance to failure at the system level in the presence of failures within components, connectors, or data.[9] Constraints CCCLUS - following these constraints ensures a RESTfull Webservice with the properties mentioned above. Client-server Architecture Separation of user interface and date storage Advantages: Portability: Multi platform Scalability: (only scale back-end for example) Statelessness No client context being stored on the server between requests Session state is held in the client Session state can be transferred by the server to another service such as a database to maintain a persistent state for a period and allow authentication Advantages: Scalability: any server can handle any request Simplicity Cacheability Responses must define themselves as cacheable or not to prevent clients from getting stale or inappropriate data in response to further requests. Eliminates some client\u2013server interactions. Scalability Performance Layered System Intermediary servers can improve system scalability by enabling load balancing and by providing shared caches. They can also enforce security policies. Scalability Reliability Code on demand Uniform interface Stateless Statelessness means that every HTTP request happens in complete isolation. When the client makes an HTTP request, it includes all information necessary for the server to fulfill that request. The server never relies on information from previous requests. If that information was important, the client would have sent it again in this request. Application State vs Resource State Application state is server-side data which servers store to identify incoming client requests, their previous interaction details, and current context information. Resource state is the current state of a resource on a server at any point of time \u2013 and it has nothing to do with the interaction between client and server. It is what you get as a response from the server as API response. You refer to it as resource representation. REST statelessness means being free on application state. Advantages of Statelessness There are some very noticeable advantages for having REST APIs stateless. Statelessness helps in scaling the APIs to millions of concurrent users by deploying it to multiple servers. Any server can handle any request because there is no session related dependency. Being stateless makes REST APIs less complex \u2013 by removing all server-side state synchronization logic. A stateless API is also easy to cache as well. A specific software can decide whether or not to cache the result of an HTTP request just by looking at that one request. There\u2019s no nagging uncertainty that state from a previous request might affect the cacheability of this one. It improves the performance of applications. The server never loses track of \u201cwhere\u201d each client is in the application because the client sends all necessary information with each request. Assembly vs Namespace vs Module An assembly provides a fundamental unit of physical code grouping. A namespace provides a fundamental unit of logical code grouping. Assembly Assembly is chunk of (precompiled) code that is physically grouped that can be executed by the .NET runtime environment. It contains one or more than one Namespaces . A .NET program consists of one or more assemblies. Assemblies are the fundamental building blocks. The code is grouped into a dll or exe. Namespace Namespace is a logical grouping of classes belongs to same functionality. First, the .NET Framework uses namespaces to organize its many classes Secondly, declaring your own namespaces can help control the scope of class and method names in larger programming projects. So System.Web and System.Data are namespaces. WCF Windows Communication Foundation, framework for building service-oriented applications. Can use multiple transport protocols (HTTP, TCP, IPC, ...). Commonly uses SOAP messages over Http. Message queuing. Yield Two advantages: * Custom iteration without creating temp collections * Stateful iteration Yield returns to the caller of the iteration, then goes back to the iteration. Normal iteration only stays in the iteration. Custom iteration Iterate without needing to create a temp collection. Easy for filtering existing lists. In example below, the yield return keeps iterating over the foreach, where a normal return would escape the function. int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; IEnumerable<int> filteredNumbers = GetNumbers(numbers); //gets a enumerable with all numbers > 5 //without needing to create a temp collection private IEnumerable<int> GetNumbers(int[] nums) { foreach (int number in nums) { if (number > 5) { yield return number; } } } Stateful iteration When doing complex computations, yield can create the advantage that you can check for results before going to the next computation. A normal iteration needs to generate the full list first, then check for results. Yield gives the advantage of deferred execution, the list is only created dynamically while looping over the list. In example below, the check of i == 3 happens on each yield return, the yield return statements of 4 and 5 never happen. example 1 private static int GetItemFromList() { foreach (int i in GetList()) { if (i == 3) { return i; } } return 0; } private static IEnumerable<int> GetList() { yield return 1; yield return 2; yield return 3; yield return 4; yield return 5; } example 2 void ConsumeLoop() { foreach (Consumable item in ProduceList()) // might have to wait here item.Consume(); } IEnumerable<Consumable> ProduceList() { while (KeepProducing()) yield return ProduceExpensiveConsumable(); // expensive } Without yield, the call to ProduceList() might take a long time because you have to complete the list before returning: //pseudo-assembly Produce consumable[0] // expensive operation, e.g. disk I/O Produce consumable[1] // waiting... Produce consumable[2] // waiting... Produce consumable[3] // completed the consumable list Consume consumable[0] // start consuming Consume consumable[1] Consume consumable[2] Consume consumable[3]","title":"Theory"},{"location":"#solid","text":"","title":"SOLID"},{"location":"#single-responsibility-principle","text":"Elke klasse of module heeft de verantwoordelijkheid over \u00e9\u00e9n functionaliteit. (Kan doorgetrokken worden tot methodes).","title":"Single Responsibility Principle"},{"location":"#openclosed","text":"\u201cSoftware entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\u201d. Je moet een klasse of module kunnen uitbreiden (open) zonder ze aan te passen (closed). Een klasse moet verschillende scenario\u2019s aankunnen die nog niet nader gedefinieerd zijn, zonder ze hiervoor aan te passen. Bvb: klasse rechthoek met lengte en breedte, en een klasse voor het berekenen van een totale oppervlakte van een verzameling van rechthoeken. Public class Rectangle { public double Width {get; set;} public double Height {get; set;} } Public class AreaCalculator { public double Area(Rectangle[] shapes) { double area = 0; foreach(var shape in shapes) { area += shape.Width*shape.Height; } return area; } } Bovenstaande klasse kan niet uitgebreid worden naar andere objecten, beter is dus de oppervlakte op object niveau, zodat de areacalculator kan uitgebreid worden naar andere objecten zoals cirkels, zonder deze te moeten aanpassen: public double Area(Shape[] shapes) { double area = 0; foreach (var shape in shapes) { area += shape.Area(); } return area; }","title":"Open/Closed"},{"location":"#liskov-substitution","text":"Elke afgeleide klasse moet gesubstitueerd kunnen worden voor zijn base/parent. Wanneer een klasse dus in plaats van zijn parent gebruikt wordt, moet alle functionaliteit op dezelfde manier blijven werken. A great example illustrating LSP (given by Uncle Bob in a podcast I heard recently) was how sometimes something that sounds right in natural language doesn't quite work in code. In mathematics, a Square is a Rectangle. Indeed it is a specialization of a rectangle. The \"is a\" makes you want to model this with inheritance. However if in code you made Square derive from Rectangle, then a Square should be usable anywhere you expect a Rectangle. This makes for some strange behavior. Imagine you had SetWidth and SetHeight methods on your Rectangle base class; this seems perfectly logical. However if your Rectangle reference pointed to a Square, then SetWidth and SetHeight doesn't make sense because setting one would change the other to match it. In this case Square fails the Liskov Substitution Test with Rectangle and the abstraction of having Square inherit from Rectangle is a bad one.","title":"Liskov Substitution"},{"location":"#interface-segregation","text":"Elke implementatie van een interface of supertype moet gebruik kunnen maken van alle methodes die overge\u00ebrfd of ge\u00efmplementeerd worden. Er zou nooit een nutteloze methode mogen ge\u00ebrfd of ge\u00efmplementeerd worden. Het opsplitsen van interfaces en klassen indien nodig. Hangt sterk samen met Single Responsibility Principle Verschil tussen Single Responsibility Principle en Interface Segregation is vanwaar je het bekijkt. Zelfde principe vanuit twee verschillende oogpunten: SRP tells us that you should only have a single responsibility in a module. ISP tells us that you should not be forced to be confronted with more than you actually need. If you want to use a print() method from interface I, you shouldn't have to instantiate a SwimmingPoolor a DriveThru class for that. More concretely, and going straight to the point, they are different views on the same idea -- SRP is more focused on the designer-side point-of-view, while ISP is more focused on the client-side point-of-view. So you're basically right. The ISP was first used and formulated by Robert C. Martin while consulting for Xerox. Xerox had created a new printer system that could perform a variety of tasks such as stapling and faxing. The software for this system was created from the ground up. As the software grew, making modifications became more and more difficult so that even the smallest change would take a redeployment cycle of an hour, which made development nearly impossible. The design problem was that a single Job class was used by almost all of the tasks. Whenever a print job or a stapling job needed to be performed, a call was made to the Job class. This resulted in a 'fat' class with multitudes of methods specific to a variety of different clients. Because of this design, a staple job would know about all the methods of the print job, even though there was no use for them. The solution suggested by Martin utilized what is today called the Interface Segregation Principle. Applied to the Xerox software, an interface layer between the Job class and its clients was added using the Dependency Inversion Principle. Instead of having one large Job class, a Staple Job interface or a Print Job interface was created that would be used by the Staple or Print classes, respectively, calling methods of the Job class. Therefore, one interface was created for each job type, which was all implemented by the Job class.","title":"Interface Segregation"},{"location":"#dependency-inversion","text":"High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. Zorgt voor Decoupling - Loose coupling In volgend voorbeeld is de hogere level klasse Notification afhankelijk van een lager level klasse Email. Bij nieuwe objecten moet de code gewijzigd worden. public class Email { public void SendEmail() { // code } } public class Notification { private Email _email; public Notification() { _email = new Email(); } public void PromotionalNotification() { _email.SendEmail(); } } We lossen deze afhankelijkheid op door een abstractie te maken tussen de twee klassen. Nu is notificatie enkel afhankelijk van een abstracte messageservice, waardoor nieuwe implementaties eenvoudig toegevoegd kunnen worden. public interface IMessageService { void SendMessage(); } public class Email : IMessageService { public void SendMessage() { // code } } public class Notification { private IMessageService _iMessageService; public Notification() { _iMessageService = new Email(); } public void PromotionalNotification() { _iMessageService.SendMessage(); } } We moeten enkel nog via Dependency Injection de afhankelijkheid weghalen door het object via de constructor te injecteren zoals hieronder. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } }","title":"Dependency Inversion"},{"location":"#dependency-inversion-vs-dependency-injection","text":"Als we in onderstaand voorbeeld geen Interface injecteren via Dependency Injection, maar een concrete implementatie via een object, dan doen we aan Dependency Injection maar niet aan Dependency Inversion: de klasse geeft de controle van het instanti\u00ebren af, maar is afhankelijk van een concrete implementatie ipv een abstractie waardoor de klassen nog steeds niet loosely coupled zijn. public class Notification { private IMessageService _iMessageService; public Notification(IMessageService _messageService) { this._iMessageService = _messageService; } public void PromotionalNotification() { _iMessageService.SendMessage(); } }","title":"Dependency Inversion vs Dependency Injection"},{"location":"#inversion-of-control","text":"'Omdraaien van de controle'. The division between the 'What' and the 'When' parts of the code. Code that does not know and care when it will run, it only knows what it will do and depend on abstractions. In traditional programming, the flow of the business logic is determined by objects that are statically bound to one another. With inversion of control, the flow depends on the object graph that is built up during program execution. Such a dynamic flow is made possible by object interactions that are defined through abstractions. This run-time binding is achieved by mechanisms such as dependency injection or a service locator. Factory pattern Service locator pattern Dpeendency injection Strategy pattern","title":"Inversion Of Control"},{"location":"#patterns","text":"","title":"Patterns"},{"location":"#factory-method-pattern","text":"In class-based programming, the factory method pattern is a creational pattern that uses factory methods to deal with the problem of creating objects without having to specify the exact class of the object that will be created, by calling a factory method rather than by calling a constructor . Puts the pieces together to make a complete object and hides the concrete type from the caller. \"Define an interface for creating an object, but let subclasses decide which class to instantiate. The Factory method lets a class defer instantiation it uses to subclasses.\" (Gang Of Four) Why and when to use: * A class cannot anticipate the type of objects it needs to create beforehand. * A class requires its subclasses to specify the objects it creates. * You want to localize the logic to instantiate a complex object.","title":"Factory method pattern"},{"location":"#abstract-factory-pattern","text":"Variant on the factory method pattern, where instead of creating object in a factory method, you use a factory class to generate objects of a certain type. This is especially usefull when creating complex objects in multiple different classes. They can all share a factory class to generate objects, and if the composition of the object changes, only the factory class needs to be changed. the Factory Method pattern uses inheritance and relies on a subclass to handle the desired object instantiation. with the Abstract Factory pattern , a class delegates the responsibility of object instantiation to another object via composition. Factory method Creates object of a subclass of Foo. Which subclass depends on the subclass of A. Inheritence is used to decide the behaviour of f.whatever(). class A { public void doSomething() { Foo f = makeFoo(); f.whatever(); } protected Foo makeFoo() { return new RegularFoo(); } } class B extends A { protected Foo makeFoo() { //subclass is overriding the factory method //to return something different return new SpecialFoo(); } } Abstract Factory Creates objects of a subclass of Foo. Which subclass depends on the specifiek factory that is injected. This way, the behaviour of f.whatever() depends on the type of factory you inject. class A { private IFactory factory; public A(IFactory factory) { this.factory = factory; } public void doSomething() { //The concrete class of \"f\" depends on the concrete class //of the factory passed into the constructor. If you provide a //different factory, you get a different Foo object. Foo f = factory.makeFoo(); f.whatever(); } } interface IFactory { Foo makeFoo(); Bar makeBar(); Aycufcn makeAmbiguousYetCommonlyUsedFakeClassName(); } //need to make concrete factories that implement the \"Factory\" interface here","title":"Abstract factory pattern"},{"location":"#strategy-pattern","text":"The strategy pattern is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use. Strategy can be assigned to an object by composition, rather then inheritance, implementing an IStrategy interface where you call for example Strategy.DoSomething(). The type of IStrategy will decide the behaviour of the method, and the object can be switched at runtime with another strategy object with another implementation. public static void Main(String[] args) { // Prepare strategies IBillingStrategy normalStrategy = new NormalStrategy(); IBillingStrategy happyHourStrategy = new HappyHourStrategy(); Customer firstCustomer = new Customer(normalStrategy); // Normal billing firstCustomer.Add(1.0, 1); // Start Happy Hour firstCustomer.Strategy = happyHourStrategy; firstCustomer.Add(1.0, 2); // New Customer Customer secondCustomer = new Customer(happyHourStrategy); secondCustomer.Add(0.8, 1); // The Customer pays firstCustomer.PrintBill(); // End Happy Hour secondCustomer.Strategy = normalStrategy; secondCustomer.Add(1.3, 2); secondCustomer.Add(2.5, 1); secondCustomer.PrintBill(); } } The entire code of above example can be found here","title":"Strategy Pattern"},{"location":"#singleton-pattern","text":"A singleton is a class which only allows one instance of itself to be created - and gives simple, easy access to said instance. This is achieved by: making the constructor private to prevent outside instantiation make a static property which contains one instance of itself public class Singleton { private Singleton() { // Prevent outside instantiation } private static readonly Singleton _singleton = new Singleton(); public static Singleton GetSingleton() { return _singleton; } }","title":"Singleton Pattern"},{"location":"#net","text":"","title":".NET"},{"location":"#net-framework","text":"The .NET Framework consists of the common language runtime (CLR) and the .NET Framework class library . De CLR (de runtime) is een virtuele machine en manages code at execution time: Geheugenbeheer Threadbeheer Exception handling Garbage collection Security Ontwikkelaars die CLR gebruiken schrijven hun code in een zogenaamd hogere programmeertaal zoals C#, Scala of VB.NET. Tijdens het compileren zorgt een .NET-compiler ervoor dat de broncode wordt omgezet naar MSIL, welke tijdens het uitvoeren door de just in time compiler van de CLR wordt gecompileerd naar code die uitgevoerd kan worden op het systeem waar de CLR op dat moment op draait. Dit zorgt ervoor dat applicaties niet hardware afhankelijk zijn, en dus op elk willekeurig systeem kunnen worden uitgevoerd, zolang er een CLR voor is. Door dit proces zijn applicaties wel (iets) trager, omdat ze tijdens het uitvoeren gecompileerd worden.","title":".NET Framework"},{"location":"#rest","text":"Excellent overview here - https://restfulapi.net/statelessness/ Representational State Transfer is a software architecture used to create web services. RESTful web services allow the requesting systems to access and manipulate textual representations of web resources by using a uniform and predefined set of stateless operations.","title":"REST"},{"location":"#architectural-properties","text":"performance in component interactions, which can be the dominant factor in user-perceived performance and network efficiency;[9] scalability allowing the support of large numbers of components and interactions among components. simplicity of a uniform interface; modifiability of components to meet changing needs (even while the application is running); visibility of communication between components by service agents; portability - usability of the same software in different environments reliability in the resistance to failure at the system level in the presence of failures within components, connectors, or data.[9]","title":"Architectural properties"},{"location":"#constraints","text":"CCCLUS - following these constraints ensures a RESTfull Webservice with the properties mentioned above.","title":"Constraints"},{"location":"#client-server-architecture","text":"Separation of user interface and date storage Advantages: Portability: Multi platform Scalability: (only scale back-end for example)","title":"Client-server Architecture"},{"location":"#statelessness","text":"No client context being stored on the server between requests Session state is held in the client Session state can be transferred by the server to another service such as a database to maintain a persistent state for a period and allow authentication Advantages: Scalability: any server can handle any request Simplicity","title":"Statelessness"},{"location":"#cacheability","text":"Responses must define themselves as cacheable or not to prevent clients from getting stale or inappropriate data in response to further requests. Eliminates some client\u2013server interactions. Scalability Performance","title":"Cacheability"},{"location":"#layered-system","text":"Intermediary servers can improve system scalability by enabling load balancing and by providing shared caches. They can also enforce security policies. Scalability Reliability","title":"Layered System"},{"location":"#code-on-demand","text":"","title":"Code on demand"},{"location":"#uniform-interface","text":"","title":"Uniform interface"},{"location":"#stateless","text":"Statelessness means that every HTTP request happens in complete isolation. When the client makes an HTTP request, it includes all information necessary for the server to fulfill that request. The server never relies on information from previous requests. If that information was important, the client would have sent it again in this request.","title":"Stateless"},{"location":"#application-state-vs-resource-state","text":"Application state is server-side data which servers store to identify incoming client requests, their previous interaction details, and current context information. Resource state is the current state of a resource on a server at any point of time \u2013 and it has nothing to do with the interaction between client and server. It is what you get as a response from the server as API response. You refer to it as resource representation. REST statelessness means being free on application state.","title":"Application State vs Resource State"},{"location":"#advantages-of-statelessness","text":"There are some very noticeable advantages for having REST APIs stateless. Statelessness helps in scaling the APIs to millions of concurrent users by deploying it to multiple servers. Any server can handle any request because there is no session related dependency. Being stateless makes REST APIs less complex \u2013 by removing all server-side state synchronization logic. A stateless API is also easy to cache as well. A specific software can decide whether or not to cache the result of an HTTP request just by looking at that one request. There\u2019s no nagging uncertainty that state from a previous request might affect the cacheability of this one. It improves the performance of applications. The server never loses track of \u201cwhere\u201d each client is in the application because the client sends all necessary information with each request.","title":"Advantages of Statelessness"},{"location":"#assembly-vs-namespace-vs-module","text":"An assembly provides a fundamental unit of physical code grouping. A namespace provides a fundamental unit of logical code grouping.","title":"Assembly vs Namespace vs Module"},{"location":"#assembly","text":"Assembly is chunk of (precompiled) code that is physically grouped that can be executed by the .NET runtime environment. It contains one or more than one Namespaces . A .NET program consists of one or more assemblies. Assemblies are the fundamental building blocks. The code is grouped into a dll or exe.","title":"Assembly"},{"location":"#namespace","text":"Namespace is a logical grouping of classes belongs to same functionality. First, the .NET Framework uses namespaces to organize its many classes Secondly, declaring your own namespaces can help control the scope of class and method names in larger programming projects. So System.Web and System.Data are namespaces.","title":"Namespace"},{"location":"#wcf","text":"Windows Communication Foundation, framework for building service-oriented applications. Can use multiple transport protocols (HTTP, TCP, IPC, ...). Commonly uses SOAP messages over Http. Message queuing.","title":"WCF"},{"location":"#yield","text":"Two advantages: * Custom iteration without creating temp collections * Stateful iteration Yield returns to the caller of the iteration, then goes back to the iteration. Normal iteration only stays in the iteration.","title":"Yield"},{"location":"#custom-iteration","text":"Iterate without needing to create a temp collection. Easy for filtering existing lists. In example below, the yield return keeps iterating over the foreach, where a normal return would escape the function. int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; IEnumerable<int> filteredNumbers = GetNumbers(numbers); //gets a enumerable with all numbers > 5 //without needing to create a temp collection private IEnumerable<int> GetNumbers(int[] nums) { foreach (int number in nums) { if (number > 5) { yield return number; } } }","title":"Custom iteration"},{"location":"#stateful-iteration","text":"When doing complex computations, yield can create the advantage that you can check for results before going to the next computation. A normal iteration needs to generate the full list first, then check for results. Yield gives the advantage of deferred execution, the list is only created dynamically while looping over the list. In example below, the check of i == 3 happens on each yield return, the yield return statements of 4 and 5 never happen. example 1 private static int GetItemFromList() { foreach (int i in GetList()) { if (i == 3) { return i; } } return 0; } private static IEnumerable<int> GetList() { yield return 1; yield return 2; yield return 3; yield return 4; yield return 5; } example 2 void ConsumeLoop() { foreach (Consumable item in ProduceList()) // might have to wait here item.Consume(); } IEnumerable<Consumable> ProduceList() { while (KeepProducing()) yield return ProduceExpensiveConsumable(); // expensive } Without yield, the call to ProduceList() might take a long time because you have to complete the list before returning: //pseudo-assembly Produce consumable[0] // expensive operation, e.g. disk I/O Produce consumable[1] // waiting... Produce consumable[2] // waiting... Produce consumable[3] // completed the consumable list Consume consumable[0] // start consuming Consume consumable[1] Consume consumable[2] Consume consumable[3]","title":"Stateful iteration"},{"location":"css/","text":"CSS Positioning elements Float float:left; The element needs to have specified width The element is removed from normal flow, but still part of the flow (unlike absolute positioning) It is shifted to the left, or right, until it touches the edge of its containing box, or another floated element. Other elements wrap around. To make sure elements go below the floated element, use clear: both Parent with only floated elements will collapse, fix by creating empty div behind parent element with clear: both or give parent element overflow: auto Flex-box Parent display: flex; --- defines the flex container flex-direction: row; --- defines the direction flex for child items justify-content: center; --- aligns child items on main axis align-items: flex-start; --- aligns child items on cross axis align-content: flex-start; --- aligns rows of items on cross axis (only when there are multipe rows of items) Child align-self: auto | center ...; --- allows default alignment to be overridden for this individual element order: <integer>; --- assigns the order of the item flex-grow: <integer>; --- defines the ability to take in more space, will overwrite the defined width (or height). The default is 0 (no grow, keep defined width). Value only has meaning relative to other flex-grow values, defines the proportion of space to take in relation to other flex objects. flex-shrink: <integer>; --- defines the ability to shrink if the container is too small. Default is 1, which means that every object will shrink equally. 0 will keep the object at its defined width. Higher values will make some object shrink faster than others. Nice link with gifs on flex-grow and flex-shrink Centering Horizontal Block element: margin: 0 auto or flexbox Text: text-align: center Vertical Block element: flexbox Text: line-height Perfect centering with flexbox Parent element: display: flex and define width and height Child element: margin: auto and define width and height Sizing elements Box-sizing With border-box, borders will grow towards the inside of the element instead of the outside. This ensures the total width of the element stays the same. Box-sizing: border-box; EM vs REM vs PX EM The em value is relative to the current font-size. If no font-size is declared in the element or parent element, the default font-size will be chosen which, in most browsers and user settings is 16px . In this instance, a value of 2em will mean 32px. Em is preferred over px because it is relative to the settings the user and browser have declared as standard. Px will override them, giving the user less options. REM REM takes the above value, but instead of being based on the current font-size of the element, it is based on the root font-size. For example: h1 { font-size: 2em; /* 1em = 16px */ margin-bottom: 1em; /* 1em = 32px */ } In the example above, the margin bottom will be 32px, because it is based on the font-size of the element h1, which is set to 2*16px. If margin-bottom is set to 1rem, it will be 16px because it is based on the root font-size.","title":"CSS"},{"location":"css/#css","text":"","title":"CSS"},{"location":"css/#positioning-elements","text":"","title":"Positioning elements"},{"location":"css/#float","text":"float:left; The element needs to have specified width The element is removed from normal flow, but still part of the flow (unlike absolute positioning) It is shifted to the left, or right, until it touches the edge of its containing box, or another floated element. Other elements wrap around. To make sure elements go below the floated element, use clear: both Parent with only floated elements will collapse, fix by creating empty div behind parent element with clear: both or give parent element overflow: auto","title":"Float"},{"location":"css/#flex-box","text":"","title":"Flex-box"},{"location":"css/#parent","text":"display: flex; --- defines the flex container flex-direction: row; --- defines the direction flex for child items justify-content: center; --- aligns child items on main axis align-items: flex-start; --- aligns child items on cross axis align-content: flex-start; --- aligns rows of items on cross axis (only when there are multipe rows of items)","title":"Parent"},{"location":"css/#child","text":"align-self: auto | center ...; --- allows default alignment to be overridden for this individual element order: <integer>; --- assigns the order of the item flex-grow: <integer>; --- defines the ability to take in more space, will overwrite the defined width (or height). The default is 0 (no grow, keep defined width). Value only has meaning relative to other flex-grow values, defines the proportion of space to take in relation to other flex objects. flex-shrink: <integer>; --- defines the ability to shrink if the container is too small. Default is 1, which means that every object will shrink equally. 0 will keep the object at its defined width. Higher values will make some object shrink faster than others. Nice link with gifs on flex-grow and flex-shrink","title":"Child"},{"location":"css/#centering","text":"","title":"Centering"},{"location":"css/#horizontal","text":"Block element: margin: 0 auto or flexbox Text: text-align: center","title":"Horizontal"},{"location":"css/#vertical","text":"Block element: flexbox Text: line-height","title":"Vertical"},{"location":"css/#perfect-centering-with-flexbox","text":"Parent element: display: flex and define width and height Child element: margin: auto and define width and height","title":"Perfect centering with flexbox"},{"location":"css/#sizing-elements","text":"","title":"Sizing elements"},{"location":"css/#box-sizing","text":"With border-box, borders will grow towards the inside of the element instead of the outside. This ensures the total width of the element stays the same. Box-sizing: border-box;","title":"Box-sizing"},{"location":"css/#em-vs-rem-vs-px","text":"","title":"EM vs REM vs PX"},{"location":"css/#em","text":"The em value is relative to the current font-size. If no font-size is declared in the element or parent element, the default font-size will be chosen which, in most browsers and user settings is 16px . In this instance, a value of 2em will mean 32px. Em is preferred over px because it is relative to the settings the user and browser have declared as standard. Px will override them, giving the user less options.","title":"EM"},{"location":"css/#rem","text":"REM takes the above value, but instead of being based on the current font-size of the element, it is based on the root font-size. For example: h1 { font-size: 2em; /* 1em = 16px */ margin-bottom: 1em; /* 1em = 32px */ } In the example above, the margin bottom will be 32px, because it is based on the font-size of the element h1, which is set to 2*16px. If margin-bottom is set to 1rem, it will be 16px because it is based on the root font-size.","title":"REM"},{"location":"git/","text":"GIT Overview Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. Example: stage, commit and push changes to remote repository called origin. git add * git commit -m \"bugfix\" git fetch origin git pull origin git push origin --all Example: push exisiting project to new remote repository (without readme) Step 1: Create local repository and commit changes git init git add . git commit -m \"Initial commit\" Step 2: add remote and push changes to remote git remote add origin remote_origin_url git remote -v (verifies then new remote URL) git push origin master Initialize git init --- create new local repository git clone --- create copy of an existing repository, automatically creates a remote connection called origin Saving changes The commands: git add , git status , and git commit are all used in combination to save a snapshot of a Git project's current state. git add --- stages changes git status --- checks which files are staged git reset --- undo a git add git commit --- commits the staged changes to the local repository Stashing changes Stashing takes your uncommitted changes (both staged and unstaged) , saves them away for later use, and then reverts them from your working copy. git stash --- temporarily shelves changes git stash pop --- reaplly stashed changes to local working copy Git stash does not stash untracked files (new files). To stash new files you can add -u (--include-untracked) git stash -u --- stashes changes with untracked files Syncing with remote repository Configuring remote A remote repository can be reached through a URL and credentials. Git remote allows you to creates an alias for easy use of the URL of the remote repository. git remote --- get current remote configurations git remote -v --- same as the above but includes the URL of each remote git remote add <name> <url> --- adds a new remote git remote rm <name> --- remove remote Pushing git push <remote> <branch> Merge vs Rebase Both try to achieve the same result, but rebase rewrites the history by 'rebasing' one branch on top of the other, creating a lineair history. This prevents cluttering with merge commits, but can create confusing situations by creating a different history with other team members. Link to explanation","title":"GIT"},{"location":"git/#git","text":"","title":"GIT"},{"location":"git/#overview","text":"Git is a version-control system for tracking changes in computer files and coordinating work on those files among multiple people. Example: stage, commit and push changes to remote repository called origin. git add * git commit -m \"bugfix\" git fetch origin git pull origin git push origin --all Example: push exisiting project to new remote repository (without readme) Step 1: Create local repository and commit changes git init git add . git commit -m \"Initial commit\" Step 2: add remote and push changes to remote git remote add origin remote_origin_url git remote -v (verifies then new remote URL) git push origin master","title":"Overview"},{"location":"git/#initialize","text":"git init --- create new local repository git clone --- create copy of an existing repository, automatically creates a remote connection called origin","title":"Initialize"},{"location":"git/#saving-changes","text":"The commands: git add , git status , and git commit are all used in combination to save a snapshot of a Git project's current state. git add --- stages changes git status --- checks which files are staged git reset --- undo a git add git commit --- commits the staged changes to the local repository","title":"Saving changes"},{"location":"git/#stashing-changes","text":"Stashing takes your uncommitted changes (both staged and unstaged) , saves them away for later use, and then reverts them from your working copy. git stash --- temporarily shelves changes git stash pop --- reaplly stashed changes to local working copy Git stash does not stash untracked files (new files). To stash new files you can add -u (--include-untracked) git stash -u --- stashes changes with untracked files","title":"Stashing changes"},{"location":"git/#syncing-with-remote-repository","text":"","title":"Syncing with remote repository"},{"location":"git/#configuring-remote","text":"A remote repository can be reached through a URL and credentials. Git remote allows you to creates an alias for easy use of the URL of the remote repository. git remote --- get current remote configurations git remote -v --- same as the above but includes the URL of each remote git remote add <name> <url> --- adds a new remote git remote rm <name> --- remove remote","title":"Configuring remote"},{"location":"git/#pushing","text":"git push <remote> <branch>","title":"Pushing"},{"location":"git/#merge-vs-rebase","text":"Both try to achieve the same result, but rebase rewrites the history by 'rebasing' one branch on top of the other, creating a lineair history. This prevents cluttering with merge commits, but can create confusing situations by creating a different history with other team members. Link to explanation","title":"Merge vs Rebase"},{"location":"linux/","text":"Linux Package management Two large package managers: Debian (Debian distribution) RPM (Standard for other distributions - Red Hat) (Name from: Red Hat Package Manager) Debian package manager Extension: .deb Command: dpkg Command line front end programs: apt-get, aptitude GUI front-ends: synaptic, software-center Commands updated list: sudo apt-get update search by keyword in packages: sudo apt-cache search 'keyword' install or update: sudo apt-get install 'package' update all packages: sudo apt-get upgrade remove package: sudo apt-get remove 'package' (--purge to also delete config files) list all packages on your system: dpkg -l list all files of package: dpkg -L 'package' check if file is part of package: dpkg -S /path/to/file RPM Package Manager Extension: .rpm Command: rpm Command line front-end: yum, up2date (automatically resolve dependencies) GUI front-end: yumex, gpk-application Commands install: yum install 'package' search: yum search 'keyword' update: yum update 'package' update all packages: yum update remove: yum remove 'package' -- also removes all dependencies Process management BIOS BIOS (Basic Input/Output System) - software in non-volatile memory (firmware) on a chip on the system board BIOS loads Bootloader from harddisk to RAM - Bootloader loads the Kernel. Multi step process is needed to decouple the Operating System from the basic BIOS on the system. Kernel Is the Core of the Computer System. Is the connection between the application software and the hardware of the machine. Memory Management Resource Management Device Management System Calls Processes Information about the processes are available in pseudo-filesystems: Running processes are visible under /proc Hardware devices are available /dev Information about these devices /sys Other commands: pstree show the Process tree ps shows current running processes top shows an overview of all processes which keeps updating (like task manager) free shows memory management","title":"Linux"},{"location":"linux/#linux","text":"","title":"Linux"},{"location":"linux/#package-management","text":"Two large package managers: Debian (Debian distribution) RPM (Standard for other distributions - Red Hat) (Name from: Red Hat Package Manager)","title":"Package management"},{"location":"linux/#debian-package-manager","text":"Extension: .deb Command: dpkg Command line front end programs: apt-get, aptitude GUI front-ends: synaptic, software-center","title":"Debian package manager"},{"location":"linux/#commands","text":"updated list: sudo apt-get update search by keyword in packages: sudo apt-cache search 'keyword' install or update: sudo apt-get install 'package' update all packages: sudo apt-get upgrade remove package: sudo apt-get remove 'package' (--purge to also delete config files) list all packages on your system: dpkg -l list all files of package: dpkg -L 'package' check if file is part of package: dpkg -S /path/to/file","title":"Commands"},{"location":"linux/#rpm-package-manager","text":"Extension: .rpm Command: rpm Command line front-end: yum, up2date (automatically resolve dependencies) GUI front-end: yumex, gpk-application","title":"RPM Package Manager"},{"location":"linux/#commands_1","text":"install: yum install 'package' search: yum search 'keyword' update: yum update 'package' update all packages: yum update remove: yum remove 'package' -- also removes all dependencies","title":"Commands"},{"location":"linux/#process-management","text":"","title":"Process management"},{"location":"linux/#bios","text":"BIOS (Basic Input/Output System) - software in non-volatile memory (firmware) on a chip on the system board BIOS loads Bootloader from harddisk to RAM - Bootloader loads the Kernel. Multi step process is needed to decouple the Operating System from the basic BIOS on the system.","title":"BIOS"},{"location":"linux/#kernel","text":"Is the Core of the Computer System. Is the connection between the application software and the hardware of the machine. Memory Management Resource Management Device Management System Calls","title":"Kernel"},{"location":"linux/#processes","text":"Information about the processes are available in pseudo-filesystems: Running processes are visible under /proc Hardware devices are available /dev Information about these devices /sys Other commands: pstree show the Process tree ps shows current running processes top shows an overview of all processes which keeps updating (like task manager) free shows memory management","title":"Processes"},{"location":"mkdocs/","text":"MkDocs Generates static sites based on markdown files. https://www.mkdocs.org mkdocs serve - Start the live-reloading docs server. Launch in directory of .yml file. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploys the pages to Github Project Pages Markdown sheat-sheet: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#lines Live Page","title":"MkDocs"},{"location":"mkdocs/#mkdocs","text":"Generates static sites based on markdown files. https://www.mkdocs.org mkdocs serve - Start the live-reloading docs server. Launch in directory of .yml file. mkdocs build - Build the documentation site. mkdocs gh-deploy - Deploys the pages to Github Project Pages Markdown sheat-sheet: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet#lines Live Page","title":"MkDocs"},{"location":"netwerkbeheer/","text":"Netwerkbeheer Nieuwe VM aanmaken Copy template to new map Rename template and map Add new VM - choose template when asked DHCP Dynamic Host Configuration Protocol. Zorgt voor de verdeling van IP-adressen . Elke DHCP-server heeft een pool van vrije IP-adressen om uit te delen, en verdeelt deze met een bepaalde lease-time, waarna deze opnieuw worden vrijgegeven. Voordelen dynamische ip-adressen: Geen ip-configuratie nodig voor elk toestel, kan centraal beheerd worden. Effici\u00ebnter omgaan met IP-adressen. Beperkt hierdoor kosten. Proces om IP-adres te verkrijgen loopt via DORA Discover : client verstuurt broadcast naar alle computers binnen Ethernet-segment. Offer : server biedt vrij IP-adres aan. Request : client doet werkelijke aanvraag voor dit IP-adres (bij \u00e9\u00e9n DHCP-server, andere DHCP-servers zien via broadcast dat hun aanbod niet nodig is) Acknowledge : server bevestigt de aanvraag Create new DHCP Server DNS Domain Name System/Server zorgt voor vertaling tussen IP-adres en naam . De DNS-Server houdt een tabel bij met Resource Records: A : Address records - hostname to ip-address AAAA : IPv6 Address records - hostname to IPv6-address CNAME : Alias - hostname to other hostname (redirects) MX : Mail Exchange record - specifiec mail server Proces DNS request surf naar www.google.com -> zoekt ip adres Twee lokale opzoekingen, daarna neemt uw dns server het over. (lokaal is dat dns server van bv. telenet) check etc/hosts daarna dns cache daarna vraagt hij aan dns server in domein. Indien DNS server in domein adres niet heeft root DNS Server .com google.com drive.google.com Active Directory Algemeen Kan niet zonder DNS! Voor AD moest je op elke PC een gebruiker aanmaken om te kunnen authenticeren. Authenticatie gaat via Kerberos op de Domain Controller (waar AD staat). Kerberos stuurt tickets voor toegang -> zie youtube video. Kleine bedrijven: kan via Azure AD, voor grote bedrijven niet voldoende (geen LDAP ondersteuning bvb.). Kan onder meerdere domeinen (subdomeinen dan eigenlijk). Maar geeft problemen voor authenticatie in cloud, dus meer en meer \u00e9\u00e9n groot domein. Functie Domein Controller(s): Host databank van AD Repliceren elkaar (niet zoals bij DNS waarbij \u00e9\u00e9n hoofd DNS (primary zone) en een backup DNS (secondary zone) Installatie Indien DNS en AD DC zelfde server zijn: * Wijzig naam server en herstart * Add role * Kies DNS erbij indien nodig * Zet IP-address en wijs DNS-server naar eigen IP-address! Group Policies Settings voor meerdere gebruikers of computers. Twee verschillende zaken: Policies: afschermen van zaken Preferences: settings die de gebruiker kan het aanpassen Client driven: de client vraagt aan de server welke policies hij/zij moet volgen Inheritence : overerving van policies (kan afgezet worden). Wordt aangegeven door uitroepteken. Enforce : wordt steeds toegepast (ook zonder inheritence). Wordt aangegeven door slotje. Steeds groeperen per functie. Bvb. alle rdp policies groeperen. Scheiding van gebruiker/groepen. Domain Controller configureren geef ip adres: 10.10 installeer rollen maak domeincontroller: cursusdom.be 5 rollen: (FSMO) (kunnen bij \u00e9\u00e9n domeincontroller) RID Master: verdeeld groepen van security identifiers aan de andere domein controllers: zijn deze op moet je opnieuw bij de RID master nieuwe keys ophalen. PDC emulator: distributie van verandering naar andere domein controllers Schema Master: houdt bij hoe u database er uit ziet. Domein Naming Master: Infrastructure Master: PC toevoegen aan domain !Moet altijd vanuit Client! To join a computer to a domain On the Start screen, typeControl Panel, and then press ENTER. Navigate to System and Security, and then click System. Under Computer name, domain, and workgroup settings, click Change settings. On the Computer Name tab, click Change. Under Member of, click Domain, type the name of the domain that this computer will join, and then click OK. Click OK, and then restart the computer. DONT RENAME AND ADD TO DOMAIN AT THE SAME TIME Via powershell: Eerst moet je DNS Server configureren, anders geraak je niet aan het domein netsh interface ipv4 add dnsserver \"Ethernet\" address=192.168.x.x index=1 Met volgende command kan je de lokale pc toevoegen aan het domein. Hierbij moet je je authenticeren met een account van het domein. netdom join %THE_COMPUTER_NAME% /domain:OPSCODEDEMO.COM /userd:Administrator /passwordd:xxx Mogelijke problemen: IP instellingen: fixed IP DNS Server Gateway instellingen Gekoppeld aan virtuele switch? Firewall? Pingen indien geen reply en bovenstaande is ok -> Firewall staat op Check of DNS werkt. (ping domein ipv ip-adres of NSLookup) AGDLP Account Global Group Domain Local Group Permission Account Global Group Domain Local Group Permission (use NTFS) Jos.Smet GG_HR DL_Facturen_R(read) centered DL_Facturen_W(write) Facturen (share map) are neat DL_Facturen_FC(fullctr) Bij folder sharen: Share altijd everyone full control en dan per gebruiker/group met NTFS Inheritance altijd uit Op examen niet rechtstreeks, maar altijd met groep structuur werken: OU: cursusdom OU: groepen/users/computers/servers groepen: Global Groups GG_HR, etc. Voordeel van computer toe te voegen op domein: iedere gebruiker binnen domein kan aanmelden via die pc pc kan beheerd worden vanaf netwerk Domain Administrator Difference between local admin and domain admin Before a Domain Controller is promoted to that role, it is a simple workgroup (standalone) server and has a local Administrator account and a local Administrators group. When you create a domain, those accounts don't go away; they're incorporated into the domain as the domain Administrator account and the domain builtin\\Administrators group. The builtin\\Administrators group has Administrative access to the Domain Controllers, but is not automatically granted administrative access to all computers within the domain, whereas Domain Admins are. WIN10 Client Computername: CL10 Username: Local_Admin Password: R1234-56 Fileserver Kan rechtstreeks (via GUI) via system - Kan eenvoudiger via de Domein Controller Server Manager All Servers Server toevoegen via zoekfunctie Functies en rollen installeren. start powershell Install-WindowsFeature \u2013Name FS-Resource-Manager Folder C:DATA sharen Beter via Server manager: fileserver - shares - tasks - new New-SMBShare \u2013Name \"Shared\" \u2013Path \"C:\\Shared\" \u2013ContinuouslyAvailable \u2013FullAccess domain\\admingroup ` Test via nieuwe netwerklocatie aan te maken: \\ServerCore\\Data Kan ook gewoon via \\ServerCore -> laat alle shared mappen zien Powershell Syntax $PSItem or $_ Gets the item in a foreach or after the pipeline. $ (dollar underscore) 'THIS' token. Typically refers to the item inside a foreach loop. Task: Print all items in a collection. Solution. ... | foreach { Write-Host $ } get-process | where-object {$_.cpu -gt 1 -and $_.company -ne 'Microsoft Corporation'} | ft name, cpu, company Comparators -eq Equal -ne Not equal -ge Greater than or equal -gt Greater than -lt Less than -le Less than or equal -like Wildcard comparison -notlike Wildcard comparison -match Regular expression comparison -notmatch Regular expression comparison -replace Replace operator -contains Containment operator -notcontains Containment operator -in Like \u2013contains, but with the operands reversed.(PowerShell 3.0) -notin Like \u2013notcontains, but with the operands reversed.(PowerShell 3.0) get-childitem | c:\\windows | where-object LastAccessTime -gt (Get-Date).AddMonths(-1) Useful commands Get-process get-process --- toont alle processen get-process -name notepad --- toont running notepad processen get-process -name n* --- toont alle processen starting with N Stop-process stop-process -name notepad --- stop all notepad processen stop-process -name notepad -whatif --- check which processes would have been stopped Get-Date Shows current date. (Get-Date).DayOfWeek --- dag van de week (Get-Date).AddYears/AddDays/ --- add amount of time to dat Get-Date -Day 1 -Month 7 -Year (Get-Date).Year --- toont op welke dag 1 juli van het huidig jaar valt Oefing Core Veel instellingen kunnen ook via sconfig naam wijzigen get current computername: hostname wmic computersystem where caption='xp-pc' rename windows7-pc ip aanpassen get name of interface: netsh interface show interface change ip adress: netsh interface ip set address \"Ethernet\" static 10.0.0.100 255.255.0.0 10.0.0.1 1 show change: netsh interface show interface windows update uitzetten BETER via powershell: stop-service wuauserv set-service wuauserv -StartupType Disabled firewall uitzetten netsh advfirewall set allprofiles state off","title":"Netwerkbeheer"},{"location":"netwerkbeheer/#netwerkbeheer","text":"","title":"Netwerkbeheer"},{"location":"netwerkbeheer/#nieuwe-vm-aanmaken","text":"Copy template to new map Rename template and map Add new VM - choose template when asked","title":"Nieuwe VM aanmaken"},{"location":"netwerkbeheer/#dhcp","text":"Dynamic Host Configuration Protocol. Zorgt voor de verdeling van IP-adressen . Elke DHCP-server heeft een pool van vrije IP-adressen om uit te delen, en verdeelt deze met een bepaalde lease-time, waarna deze opnieuw worden vrijgegeven. Voordelen dynamische ip-adressen: Geen ip-configuratie nodig voor elk toestel, kan centraal beheerd worden. Effici\u00ebnter omgaan met IP-adressen. Beperkt hierdoor kosten. Proces om IP-adres te verkrijgen loopt via DORA Discover : client verstuurt broadcast naar alle computers binnen Ethernet-segment. Offer : server biedt vrij IP-adres aan. Request : client doet werkelijke aanvraag voor dit IP-adres (bij \u00e9\u00e9n DHCP-server, andere DHCP-servers zien via broadcast dat hun aanbod niet nodig is) Acknowledge : server bevestigt de aanvraag","title":"DHCP"},{"location":"netwerkbeheer/#create-new-dhcp-server","text":"","title":"Create new DHCP Server"},{"location":"netwerkbeheer/#dns","text":"Domain Name System/Server zorgt voor vertaling tussen IP-adres en naam . De DNS-Server houdt een tabel bij met Resource Records: A : Address records - hostname to ip-address AAAA : IPv6 Address records - hostname to IPv6-address CNAME : Alias - hostname to other hostname (redirects) MX : Mail Exchange record - specifiec mail server","title":"DNS"},{"location":"netwerkbeheer/#proces-dns-request","text":"surf naar www.google.com -> zoekt ip adres Twee lokale opzoekingen, daarna neemt uw dns server het over. (lokaal is dat dns server van bv. telenet) check etc/hosts daarna dns cache daarna vraagt hij aan dns server in domein. Indien DNS server in domein adres niet heeft root DNS Server .com google.com drive.google.com","title":"Proces DNS request"},{"location":"netwerkbeheer/#active-directory","text":"","title":"Active Directory"},{"location":"netwerkbeheer/#algemeen","text":"Kan niet zonder DNS! Voor AD moest je op elke PC een gebruiker aanmaken om te kunnen authenticeren. Authenticatie gaat via Kerberos op de Domain Controller (waar AD staat). Kerberos stuurt tickets voor toegang -> zie youtube video. Kleine bedrijven: kan via Azure AD, voor grote bedrijven niet voldoende (geen LDAP ondersteuning bvb.). Kan onder meerdere domeinen (subdomeinen dan eigenlijk). Maar geeft problemen voor authenticatie in cloud, dus meer en meer \u00e9\u00e9n groot domein. Functie Domein Controller(s): Host databank van AD Repliceren elkaar (niet zoals bij DNS waarbij \u00e9\u00e9n hoofd DNS (primary zone) en een backup DNS (secondary zone)","title":"Algemeen"},{"location":"netwerkbeheer/#installatie","text":"Indien DNS en AD DC zelfde server zijn: * Wijzig naam server en herstart * Add role * Kies DNS erbij indien nodig * Zet IP-address en wijs DNS-server naar eigen IP-address!","title":"Installatie"},{"location":"netwerkbeheer/#group-policies","text":"Settings voor meerdere gebruikers of computers. Twee verschillende zaken: Policies: afschermen van zaken Preferences: settings die de gebruiker kan het aanpassen Client driven: de client vraagt aan de server welke policies hij/zij moet volgen Inheritence : overerving van policies (kan afgezet worden). Wordt aangegeven door uitroepteken. Enforce : wordt steeds toegepast (ook zonder inheritence). Wordt aangegeven door slotje. Steeds groeperen per functie. Bvb. alle rdp policies groeperen. Scheiding van gebruiker/groepen.","title":"Group Policies"},{"location":"netwerkbeheer/#domain-controller-configureren","text":"geef ip adres: 10.10 installeer rollen maak domeincontroller: cursusdom.be 5 rollen: (FSMO) (kunnen bij \u00e9\u00e9n domeincontroller) RID Master: verdeeld groepen van security identifiers aan de andere domein controllers: zijn deze op moet je opnieuw bij de RID master nieuwe keys ophalen. PDC emulator: distributie van verandering naar andere domein controllers Schema Master: houdt bij hoe u database er uit ziet. Domein Naming Master: Infrastructure Master:","title":"Domain Controller configureren"},{"location":"netwerkbeheer/#pc-toevoegen-aan-domain","text":"!Moet altijd vanuit Client! To join a computer to a domain On the Start screen, typeControl Panel, and then press ENTER. Navigate to System and Security, and then click System. Under Computer name, domain, and workgroup settings, click Change settings. On the Computer Name tab, click Change. Under Member of, click Domain, type the name of the domain that this computer will join, and then click OK. Click OK, and then restart the computer. DONT RENAME AND ADD TO DOMAIN AT THE SAME TIME Via powershell: Eerst moet je DNS Server configureren, anders geraak je niet aan het domein netsh interface ipv4 add dnsserver \"Ethernet\" address=192.168.x.x index=1 Met volgende command kan je de lokale pc toevoegen aan het domein. Hierbij moet je je authenticeren met een account van het domein. netdom join %THE_COMPUTER_NAME% /domain:OPSCODEDEMO.COM /userd:Administrator /passwordd:xxx","title":"PC toevoegen aan domain"},{"location":"netwerkbeheer/#mogelijke-problemen","text":"IP instellingen: fixed IP DNS Server Gateway instellingen Gekoppeld aan virtuele switch? Firewall? Pingen indien geen reply en bovenstaande is ok -> Firewall staat op Check of DNS werkt. (ping domein ipv ip-adres of NSLookup)","title":"Mogelijke problemen:"},{"location":"netwerkbeheer/#agdlp","text":"Account Global Group Domain Local Group Permission Account Global Group Domain Local Group Permission (use NTFS) Jos.Smet GG_HR DL_Facturen_R(read) centered DL_Facturen_W(write) Facturen (share map) are neat DL_Facturen_FC(fullctr) Bij folder sharen: Share altijd everyone full control en dan per gebruiker/group met NTFS Inheritance altijd uit Op examen niet rechtstreeks, maar altijd met groep structuur werken: OU: cursusdom OU: groepen/users/computers/servers groepen: Global Groups GG_HR, etc. Voordeel van computer toe te voegen op domein: iedere gebruiker binnen domein kan aanmelden via die pc pc kan beheerd worden vanaf netwerk","title":"AGDLP"},{"location":"netwerkbeheer/#domain-administrator","text":"","title":"Domain Administrator"},{"location":"netwerkbeheer/#difference-between-local-admin-and-domain-admin","text":"Before a Domain Controller is promoted to that role, it is a simple workgroup (standalone) server and has a local Administrator account and a local Administrators group. When you create a domain, those accounts don't go away; they're incorporated into the domain as the domain Administrator account and the domain builtin\\Administrators group. The builtin\\Administrators group has Administrative access to the Domain Controllers, but is not automatically granted administrative access to all computers within the domain, whereas Domain Admins are.","title":"Difference between local admin and domain admin"},{"location":"netwerkbeheer/#win10-client","text":"Computername: CL10 Username: Local_Admin Password: R1234-56","title":"WIN10 Client"},{"location":"netwerkbeheer/#fileserver","text":"Kan rechtstreeks (via GUI) via system - Kan eenvoudiger via de Domein Controller Server Manager All Servers Server toevoegen via zoekfunctie Functies en rollen installeren. start powershell Install-WindowsFeature \u2013Name FS-Resource-Manager Folder C:DATA sharen Beter via Server manager: fileserver - shares - tasks - new New-SMBShare \u2013Name \"Shared\" \u2013Path \"C:\\Shared\" \u2013ContinuouslyAvailable \u2013FullAccess domain\\admingroup ` Test via nieuwe netwerklocatie aan te maken: \\ServerCore\\Data Kan ook gewoon via \\ServerCore -> laat alle shared mappen zien","title":"Fileserver"},{"location":"netwerkbeheer/#powershell","text":"","title":"Powershell"},{"location":"netwerkbeheer/#syntax","text":"","title":"Syntax"},{"location":"netwerkbeheer/#psitem-or-_","text":"Gets the item in a foreach or after the pipeline. $ (dollar underscore) 'THIS' token. Typically refers to the item inside a foreach loop. Task: Print all items in a collection. Solution. ... | foreach { Write-Host $ } get-process | where-object {$_.cpu -gt 1 -and $_.company -ne 'Microsoft Corporation'} | ft name, cpu, company","title":"$PSItem or $_"},{"location":"netwerkbeheer/#comparators","text":"-eq Equal -ne Not equal -ge Greater than or equal -gt Greater than -lt Less than -le Less than or equal -like Wildcard comparison -notlike Wildcard comparison -match Regular expression comparison -notmatch Regular expression comparison -replace Replace operator -contains Containment operator -notcontains Containment operator -in Like \u2013contains, but with the operands reversed.(PowerShell 3.0) -notin Like \u2013notcontains, but with the operands reversed.(PowerShell 3.0) get-childitem | c:\\windows | where-object LastAccessTime -gt (Get-Date).AddMonths(-1)","title":"Comparators"},{"location":"netwerkbeheer/#useful-commands","text":"","title":"Useful commands"},{"location":"netwerkbeheer/#get-process","text":"get-process --- toont alle processen get-process -name notepad --- toont running notepad processen get-process -name n* --- toont alle processen starting with N","title":"Get-process"},{"location":"netwerkbeheer/#stop-process","text":"stop-process -name notepad --- stop all notepad processen stop-process -name notepad -whatif --- check which processes would have been stopped","title":"Stop-process"},{"location":"netwerkbeheer/#get-date","text":"Shows current date. (Get-Date).DayOfWeek --- dag van de week (Get-Date).AddYears/AddDays/ --- add amount of time to dat Get-Date -Day 1 -Month 7 -Year (Get-Date).Year --- toont op welke dag 1 juli van het huidig jaar valt Oefing Core Veel instellingen kunnen ook via sconfig naam wijzigen get current computername: hostname wmic computersystem where caption='xp-pc' rename windows7-pc ip aanpassen get name of interface: netsh interface show interface change ip adress: netsh interface ip set address \"Ethernet\" static 10.0.0.100 255.255.0.0 10.0.0.1 1 show change: netsh interface show interface windows update uitzetten BETER via powershell: stop-service wuauserv set-service wuauserv -StartupType Disabled firewall uitzetten netsh advfirewall set allprofiles state off","title":"Get-Date"},{"location":"soap/","text":"SOAP Simple Object Access Protocol Protocol Communicatie tussen verschillende componenten XML Http, of SMTP, FTP, ...","title":"SOAP"},{"location":"soap/#soap","text":"Simple Object Access Protocol Protocol Communicatie tussen verschillende componenten XML Http, of SMTP, FTP, ...","title":"SOAP"},{"location":"web_api/","text":"REST API Return types OVERZICHT Link to Microsoft Documentations POST 201 Created 400 Bad Request Return the path to get the created item. You can also include the created item in the body. return CreatedAtAction(nameof(GetById), new { id = product.Id }, product); PUT/PATCH 204 NoContent 400 Bad Request 404 Not Found GET BY ID 200 Ok 404 Not Found GET ALL 200 Ok (returns empty list if no objects are found)","title":"REST API"},{"location":"web_api/#rest-api","text":"","title":"REST API"},{"location":"web_api/#return-types","text":"OVERZICHT Link to Microsoft Documentations","title":"Return types"},{"location":"web_api/#post","text":"201 Created 400 Bad Request Return the path to get the created item. You can also include the created item in the body. return CreatedAtAction(nameof(GetById), new { id = product.Id }, product);","title":"POST"},{"location":"web_api/#putpatch","text":"204 NoContent 400 Bad Request 404 Not Found","title":"PUT/PATCH"},{"location":"web_api/#get-by-id","text":"200 Ok 404 Not Found","title":"GET BY ID"},{"location":"web_api/#get-all","text":"200 Ok (returns empty list if no objects are found)","title":"GET ALL"},{"location":"webhosting/","text":"WebHosting Hosting ASP.NET Core in IIS https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-2.2","title":"WebHosting"},{"location":"webhosting/#webhosting","text":"Hosting ASP.NET Core in IIS https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/?view=aspnetcore-2.2","title":"WebHosting"}]}